---
import RichText from '@components/RichText/index.astro';
import { formatTimestamp } from '../../utils/player';
import { PlayCircleIcon } from '@heroicons/react/24/outline';
import TagPill from '@components/tags/TagPill.astro';
import AutoscrollSwitch from '@components/AnnotationUI/AutoscrollSwitch';
import HideTagsSwitch from '@components/AnnotationUI/HideTagsSwitch';
import TextSearch from '@components/AnnotationUI/TextSearch';
import { getEntry } from 'astro:content';
import TagFilter from './TagFilter';

const projectData = await getEntry('project', 'project');

export interface Props {
  playerId: string;
  annotations: any[];
  sticky?: boolean;
}

const { playerId, annotations, sticky = false } = Astro.props;

const tagGroups: { category: string; color: string }[] =
  // @ts-ignore
  projectData.data.project.tags.tagGroups;

let allTags: { [key: string]: { tags: string[]; color: string } } = {};
if (annotations && annotations.length) {
  annotations.forEach((ann) => {
    if (ann.tags && ann.tags.length) {
      ann.tags.forEach((tag: { category: string; tag: string }) => {
        allTags[tag.category] ||= {
          tags: [],
          color:
            tagGroups.find(
              (grp) => grp.category.toLowerCase() == tag.category.toLowerCase()
            )?.color || '#FFF',
        };
        if (!allTags[tag.category].tags.includes(tag.tag)) {
          allTags[tag.category].tags.push(tag.tag);
          allTags[tag.category].tags.sort();
        }
      });
    }
  });
}
---

<div class='flex flex-col'>
  <div
    class={`flex flex-row w-full justify-between items-center py-4${sticky ? ' sticky top-14' : ''}`}
  >
    <h3 class='font-bold text-lg'>Annotations</h3>
    <div class='flex flex-row gap-8 items-center'>
      <AutoscrollSwitch playerId={playerId} client:only='react' />
      <HideTagsSwitch playerId={playerId} client:only='react' />
      <TextSearch playerId={playerId} client:only='react' />
      <TagFilter playerId={playerId} tags={allTags} client:only='react' />
    </div>
  </div>
  <div class='sticky top-[300px] overflow-y-visible w-full'>
    <div
      class={`border border-collapse border-black overflow-y-scroll max-h-[calc(100dvh_-260px)] relative`}
      id={playerId}
    >
      {
        annotations.map((ann: any) => {
          return (
            <div
              class='annotationNode flex flex-row justify-between gap-4 p-4 border-t border-b border-t-black border-b-black'
              data-start={ann.start_time}
              data-end={ann.end_time}
              data-tags={JSON.stringify(ann.tags)}
            >
              <div class='flex flex-row gap-2 w-[10%] items-start'>
                <button
                  class='playAnnotation'
                  data-start={ann.start_time}
                  data-end={ann.end_time}
                  data-player-id={playerId}
                >
                  <PlayCircleIcon className='h-6 w-6' />
                </button>
                <p class='w-[10%] font-semibold text-sm'>{`${formatTimestamp(ann.start_time, false)}-${formatTimestamp(ann.end_time, false)}`}</p>
              </div>
              <div class='w-[90%] flex flex-col gap-4'>
                <RichText nodes={ann.annotation} />
                <div
                  class='flex flex-row gap-4 annotationTags'
                  data-player-id={playerId}
                >
                  {ann.tags?.map((tag: any) => {
                    const group = tagGroups.find(
                      (group) =>
                        group.category.toLowerCase() ==
                        tag.category.toLowerCase()
                    );
                    return (
                      <TagPill
                        tag={tag.tag}
                        color={group ? group.color : '#FFF'}
                      />
                    );
                  })}
                </div>
              </div>
            </div>
          );
        })
      }
    </div>
  </div>
</div>

<script>
  import { $pagePlayersState } from 'src/store.ts';
  const annotationPlayNodes = document.getElementsByClassName('playAnnotation');
  const annotationNodes = document.getElementsByClassName('annotationNode');
  const annotationTagNodes = document.getElementsByClassName('annotationTags');
  for (let i = 0; i < annotationPlayNodes.length; i++) {
    const thisNode = annotationPlayNodes[i];
    if (
      thisNode instanceof HTMLElement &&
      thisNode.dataset.start &&
      thisNode.dataset.playerId
    ) {
      const annotationStartsNew =
        $pagePlayersState.get()[thisNode.dataset.playerId].annotationStarts;
      if (annotationStartsNew) {
        annotationStartsNew.push({
          start: Math.floor(Number(thisNode.dataset.start)),
          end:
            Math.floor(Number(thisNode.dataset.end)) >
            Math.floor(Number(thisNode.dataset.start))
              ? Math.floor(Number(thisNode.dataset.end))
              : undefined,
        });
        $pagePlayersState.setKey(thisNode.dataset.playerId, {
          ...$pagePlayersState.get()[thisNode.dataset.playerId],
          annotationStarts: annotationStartsNew,
        });
      }
      thisNode.addEventListener('click', () => {
        const playerId = thisNode.dataset.playerId || 'null';
        $pagePlayersState.setKey(playerId, {
          ...$pagePlayersState.get()[playerId],
          position: Number(thisNode.dataset.start),
          seekTo: Number(thisNode.dataset.start),
          isPlaying: true,
        });
      });
    }
  }

  const activeBackground = 'bg-blue-hover';

  $pagePlayersState.listen((state, oldState, changed) => {
    if (
      changed &&
      Math.floor(state[changed].position * 1000) % 7 == 0 //this is just meant to get it firing at a reasonable interval...should find a less random way
    ) {
      const startTimes = state[changed].annotationStarts;
      const current = startTimes?.findIndex((time, idx) => {
        if (typeof time.end == 'number') {
          return (
            time.start <= state[changed].position &&
            time.end > state[changed].position
          );
        }
        return idx < startTimes.length - 1
          ? time.start <= state[changed].position &&
              startTimes[idx + 1].start > state[changed].position
          : time.start <= state[changed].position;
      });
      if (typeof current == 'number' && current >= 0) {
        const activeNode = annotationNodes[current];
        if (state[changed].autoScroll) {
          activeNode.scrollIntoView({ block: 'center', behavior: 'smooth' });
        }
        activeNode.classList.add(activeBackground);
        for (let i = 0; i < annotationNodes.length; i++) {
          if (i != current) {
            annotationNodes[i].classList.remove(activeBackground);
          }
        }
      }
    }
    //show or hide tags if necessary
    if (changed && state[changed].hideTags != oldState[changed].hideTags) {
      if (state[changed].hideTags) {
        for (let i = 0; i < annotationTagNodes.length; i++) {
          annotationTagNodes[i].classList.remove('flex');
          annotationTagNodes[i].classList.add('hidden');
        }
      } else {
        for (let i = 0; i < annotationTagNodes.length; i++) {
          annotationTagNodes[i].classList.remove('hidden');
          annotationTagNodes[i].classList.add('flex');
        }
      }
    }
    //filter on text and tags
    if (
      changed &&
      (state[changed].searchQuery != oldState[changed].searchQuery ||
        state[changed].activeFilters != oldState[changed].activeFilters)
    ) {
      for (let i = 0; i < annotationNodes.length; i++) {
        const thisNode = annotationNodes[i];
        const text = thisNode.textContent;
        let tags: any[] = [];
        if (thisNode instanceof HTMLElement && thisNode.dataset.tags) {
          tags = JSON.parse(thisNode.dataset.tags);
        }
        if (
          (!state[changed].searchQuery || state[changed].searchQuery == '') &&
          (!state[changed].activeFilters ||
            !state[changed]!.activeFilters.length)
        ) {
          thisNode.classList.remove('hidden');
          thisNode.classList.add('flex');
          continue;
        } else if (
          state[changed].searchQuery?.length &&
          !text
            ?.toLowerCase()
            .includes(state[changed]!.searchQuery.toLowerCase())
        ) {
          thisNode.classList.add('hidden');
          thisNode.classList.remove('flex');
          continue;
        } else if (state[changed].activeFilters?.length) {
          let show = false;
          for (let j = 0; j < state[changed]!.activeFilters.length; j++) {
            const tag = state[changed]!.activeFilters[j];
            if (
              tags.find(
                (t) =>
                  t.category.toLowerCase() == tag.category.toLowerCase() &&
                  t.tag.toLowerCase() == tag.tag.toLowerCase()
              )
            ) {
              show = true;
              break;
            }
          }
          if (show) {
            thisNode.classList.remove('hidden');
            thisNode.classList.add('flex');
          } else {
            thisNode.classList.remove('flex');
            thisNode.classList.add('hidden');
          }
        } else {
          //we can only get here if there's a text filter but no tag filters and the node is a match for the text query, so it should be shown
          thisNode.classList.remove('hidden');
          thisNode.classList.add('flex');
        }
      }
    }
  });
</script>
