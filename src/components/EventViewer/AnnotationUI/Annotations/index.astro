---
import { type CollectionEntry } from 'astro:content';
import Annotation from './Annotation.astro';

export interface Props {
  playerId: string;
  annotationSets: CollectionEntry<'annotations'>[];
  type: 'Audio' | 'Video';
}

const { playerId, annotationSets, type } = Astro.props;

const sortedAnnotations = annotationSets
  .map((set) => set.data.annotations.map((ann) => ({ ...ann, set: set.id })))
  .flat()
  .sort((a: any, b: any) => a.start_time - b.start_time);
---

<div class={`flex flex-col`}>
  <div
    class=`top-[300px] overflow-y-visible w-full ${type === 'Audio' ? 'sticky' : ''}`
  >
    <div
      class={`${type === 'Video' ? 'overflow-y-scroll max-h-[calc(100dvh_-360px)]' : ''}`}
      id={playerId}
    >
      {
        sortedAnnotations.map((ann) => {
          return <Annotation ann={ann} playerId={playerId} />;
        })
      }
    </div>
  </div>
</div>

<script>
  import type { Tag } from '@ty/index.ts';
  import { $pagePlayersState } from 'src/store.ts';
  const annotationPlayNodes = document.getElementsByClassName('playAnnotation');
  const annotationNodes = document.getElementsByClassName('annotationNode');
  const annotationTagNodes = document.getElementsByClassName('annotationTags');
  for (let i = 0; i < annotationPlayNodes.length; i++) {
    const thisNode = annotationPlayNodes[i];
    if (
      thisNode instanceof HTMLElement &&
      thisNode.dataset.start &&
      thisNode.dataset.playerId
    ) {
      const annotationStartsNew =
        $pagePlayersState.get()[thisNode.dataset.playerId].annotationStarts;
      if (annotationStartsNew) {
        annotationStartsNew.push({
          start: Math.floor(Number(thisNode.dataset.start)),
          end:
            Math.floor(Number(thisNode.dataset.end)) >
            Math.floor(Number(thisNode.dataset.start))
              ? Math.floor(Number(thisNode.dataset.end))
              : undefined,
        });
        $pagePlayersState.setKey(thisNode.dataset.playerId, {
          ...$pagePlayersState.get()[thisNode.dataset.playerId],
          annotationStarts: annotationStartsNew,
        });
      }
      thisNode.addEventListener('click', () => {
        const playerId = thisNode.dataset.playerId || 'null';
        $pagePlayersState.setKey(playerId, {
          ...$pagePlayersState.get()[playerId],
          position: Number(thisNode.dataset.start),
          seekTo: Number(thisNode.dataset.start),
          isPlaying: true,
        });
      });
    }
  }

  const activeBackground = '!bg-blue-hover';

  $pagePlayersState.listen((state, oldState, changed) => {
    if (
      changed &&
      Math.floor(state[changed].position * 1000) % 7 === 0 //this is just meant to get it firing at a reasonable interval...should find a less random way
    ) {
      const startTimes = state[changed].annotationStarts;
      const current = startTimes?.findIndex((time, idx) => {
        if (typeof time.end === 'number') {
          return (
            time.start <= state[changed].position &&
            time.end > state[changed].position
          );
        }
        return idx < startTimes.length - 1
          ? time.start <= state[changed].position &&
              startTimes[idx + 1].start > state[changed].position
          : time.start <= state[changed].position;
      });
      if (typeof current === 'number' && current >= 0) {
        const activeNode = annotationNodes[current];
        if (state[changed].autoScroll) {
          activeNode.scrollIntoView({ block: 'center', behavior: 'smooth' });
        }
        activeNode.classList.add(activeBackground);
        for (let i = 0; i < annotationNodes.length; i++) {
          if (i != current) {
            annotationNodes[i].classList.remove(activeBackground);
          }
        }
      }
    }
    //show or hide tags if necessary
    if (changed && state[changed].showTags != oldState[changed].showTags) {
      if (state[changed].showTags) {
        for (let i = 0; i < annotationTagNodes.length; i++) {
          annotationTagNodes[i].classList.remove('hidden');
          annotationTagNodes[i].classList.add('flex');
        }
      } else {
        for (let i = 0; i < annotationTagNodes.length; i++) {
          annotationTagNodes[i].classList.remove('flex');
          annotationTagNodes[i].classList.add('hidden');
        }
      }
    }

    //filter on sets, text, and tags
    if (changed) {
      for (let i = 0; i < annotationNodes.length; i++) {
        const thisNode = annotationNodes[i];

        // hide if its set is hidden
        if (state[changed].sets.length > 0) {
          const setFiltersEmpty = state[changed].sets.length === 0;
          const set = thisNode.getAttribute('data-set');

          if (set && !setFiltersEmpty && !state[changed].sets.includes(set)) {
            thisNode.classList.remove('flex');
            thisNode.classList.add('hidden');
            continue;
          }
        }

        // hide if its sets are hidden
        if (state[changed].tags.length > 0) {
          const tags =
            thisNode instanceof HTMLElement && thisNode.dataset.tags
              ? (JSON.parse(thisNode.dataset.tags) as Tag[])
              : null;

          if (tags) {
            let match = false;
            for (let i = 0; i < tags.length; i++) {
              const tag = tags[i];
              if (
                state[changed].tags.find(
                  (tf) =>
                    tf.category.toLowerCase() === tag.category.toLowerCase() &&
                    tf.tag.toLowerCase() === tag.tag.toLowerCase()
                )
              ) {
                match = true;
                break;
              }
            }

            if (!match) {
              thisNode.classList.remove('flex');
              thisNode.classList.add('hidden');
              continue;
            }
          }
        }

        // hide if the search query doesn't include any of its text
        if (state[changed].searchQuery) {
          const text = thisNode.textContent;

          if (text) {
            const match = text
              .toLowerCase()
              .includes(state[changed].searchQuery.toLowerCase());

            if (!match) {
              thisNode.classList.remove('flex');
              thisNode.classList.add('hidden');
              continue;
            }
          }
        }

        // display the annotation if it passed all the above checks
        thisNode.classList.add('flex');
        thisNode.classList.remove('hidden');
      }
    }
  });
</script>
