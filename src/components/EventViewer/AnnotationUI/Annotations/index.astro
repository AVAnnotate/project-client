---
import { type CollectionEntry } from 'astro:content';
import Annotation from './Annotation.astro';

export interface Props {
  playerId: string;
  annotationSet: CollectionEntry<'annotations'>;
  type: 'Audio' | 'Video';
}

const { playerId, annotationSet, type } = Astro.props;

const sortedAnnotations = annotationSet.data.annotations.sort(
  (a: any, b: any) => a.start_time - b.start_time
);
---

<div class={`flex flex-col`}>
  <div
    class=`top-[300px] overflow-y-visible w-full ${type === 'Audio' ? 'sticky' : ''}`
  >
    <div
      class={`${type === 'Video' ? 'overflow-y-scroll max-h-[calc(100dvh_-360px)]' : ''}`}
      id={playerId}
    >
      {
        sortedAnnotations.map((ann: any) => {
          return <Annotation ann={ann} playerId={playerId} />;
        })
      }
    </div>
  </div>
</div>

<script>
  import { $pagePlayersState } from 'src/store.ts';
  const annotationPlayNodes = document.getElementsByClassName('playAnnotation');
  const annotationNodes = document.getElementsByClassName('annotationNode');
  const annotationTagNodes = document.getElementsByClassName('annotationTags');
  for (let i = 0; i < annotationPlayNodes.length; i++) {
    const thisNode = annotationPlayNodes[i];
    if (
      thisNode instanceof HTMLElement &&
      thisNode.dataset.start &&
      thisNode.dataset.playerId
    ) {
      const annotationStartsNew =
        $pagePlayersState.get()[thisNode.dataset.playerId].annotationStarts;
      if (annotationStartsNew) {
        annotationStartsNew.push({
          start: Math.floor(Number(thisNode.dataset.start)),
          end:
            Math.floor(Number(thisNode.dataset.end)) >
            Math.floor(Number(thisNode.dataset.start))
              ? Math.floor(Number(thisNode.dataset.end))
              : undefined,
        });
        $pagePlayersState.setKey(thisNode.dataset.playerId, {
          ...$pagePlayersState.get()[thisNode.dataset.playerId],
          annotationStarts: annotationStartsNew,
        });
      }
      thisNode.addEventListener('click', () => {
        const playerId = thisNode.dataset.playerId || 'null';
        $pagePlayersState.setKey(playerId, {
          ...$pagePlayersState.get()[playerId],
          position: Number(thisNode.dataset.start),
          seekTo: Number(thisNode.dataset.start),
          isPlaying: true,
        });
      });
    }
  }

  const activeBackground = '!bg-blue-hover';

  $pagePlayersState.listen((state, oldState, changed) => {
    if (
      changed &&
      Math.floor(state[changed].position * 1000) % 7 === 0 //this is just meant to get it firing at a reasonable interval...should find a less random way
    ) {
      const startTimes = state[changed].annotationStarts;
      const current = startTimes?.findIndex((time, idx) => {
        if (typeof time.end === 'number') {
          return (
            time.start <= state[changed].position &&
            time.end > state[changed].position
          );
        }
        return idx < startTimes.length - 1
          ? time.start <= state[changed].position &&
              startTimes[idx + 1].start > state[changed].position
          : time.start <= state[changed].position;
      });
      if (typeof current === 'number' && current >= 0) {
        const activeNode = annotationNodes[current];
        if (state[changed].autoScroll) {
          activeNode.scrollIntoView({ block: 'center', behavior: 'smooth' });
        }
        activeNode.classList.add(activeBackground);
        for (let i = 0; i < annotationNodes.length; i++) {
          if (i != current) {
            annotationNodes[i].classList.remove(activeBackground);
          }
        }
      }
    }
    //show or hide tags if necessary
    if (changed && state[changed].showTags != oldState[changed].showTags) {
      if (state[changed].showTags) {
        for (let i = 0; i < annotationTagNodes.length; i++) {
          annotationTagNodes[i].classList.remove('hidden');
          annotationTagNodes[i].classList.add('flex');
        }
      } else {
        for (let i = 0; i < annotationTagNodes.length; i++) {
          annotationTagNodes[i].classList.remove('flex');
          annotationTagNodes[i].classList.add('hidden');
        }
      }
    }
    //filter on text and tags
    if (
      changed &&
      (state[changed].searchQuery != oldState[changed].searchQuery ||
        state[changed].activeFilters != oldState[changed].activeFilters)
    ) {
      for (let i = 0; i < annotationNodes.length; i++) {
        const thisNode = annotationNodes[i];
        const text = thisNode.textContent;
        let tags: any[] = [];
        if (thisNode instanceof HTMLElement && thisNode.dataset.tags) {
          tags = JSON.parse(thisNode.dataset.tags);
        }
        if (
          (!state[changed].searchQuery || state[changed].searchQuery === '') &&
          (!state[changed].activeFilters ||
            // @ts-ignore
            !state[changed]!.activeFilters.length)
        ) {
          thisNode.classList.remove('hidden');
          thisNode.classList.add('flex');
          continue;
        } else if (
          state[changed].searchQuery?.length &&
          !text
            ?.toLowerCase()
            // @ts-ignore
            .includes(state[changed]!.searchQuery.toLowerCase())
        ) {
          thisNode.classList.add('hidden');
          thisNode.classList.remove('flex');
          continue;
        } else if (state[changed].activeFilters?.length) {
          let show = false;
          // @ts-ignore
          for (let j = 0; j < state[changed]!.activeFilters.length; j++) {
            // @ts-ignore
            const tag = state[changed]!.activeFilters[j];
            if (
              tags.find(
                (t) =>
                  t.category.toLowerCase() === tag.category.toLowerCase() &&
                  t.tag.toLowerCase() === tag.tag.toLowerCase()
              )
            ) {
              show = true;
              break;
            }
          }
          if (show) {
            thisNode.classList.remove('hidden');
            thisNode.classList.add('flex');
          } else {
            thisNode.classList.remove('flex');
            thisNode.classList.add('hidden');
          }
        } else {
          //we can only get here if there's a text filter but no tag filters and the node is a match for the text query, so it should be shown
          thisNode.classList.remove('hidden');
          thisNode.classList.add('flex');
        }
      }
    }
  });
</script>
